name: Neko Docker Telegram Bot (VPN Protected)

on:
  workflow_dispatch:
    inputs:
      chatid:
        description: "Chat ID"
        required: true
      image:
        description: "Image to use"
        required: true
      bottoken:
        description: "Telegram Bot Token"
        required: true
      cloudflaretoken:
        description: "Cloudflare Tunnel Token (optional)"
        required: false
        default: ""

jobs:
  run-neko-docker:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Generate Random Passwords
      run: |
        NEKO_PASSWORD=$(cat /dev/urandom | tr -dc 'A-Za-z0-9' | head -c 12)
        NEKO_PASSWORD_ADMIN=$(cat /dev/urandom | tr -dc 'A-Za-z0-9' | head -c 16)
        echo "::add-mask::$NEKO_PASSWORD"
        echo "::add-mask::$NEKO_PASSWORD_ADMIN"
        echo "NEKO_PASSWORD=$NEKO_PASSWORD" >> $GITHUB_ENV
        echo "NEKO_PASSWORD_ADMIN=$NEKO_PASSWORD_ADMIN" >> $GITHUB_ENV

    - name: Mask Sensitive Inputs
      run: |
        echo "::add-mask::${{ github.event.inputs.bottoken }}"
        echo "::add-mask::${{ github.event.inputs.chatid }}"
        echo "::add-mask::${{ github.event.inputs.cloudflaretoken }}"
        echo "TELEGRAM_BOT_TOKEN=${{ github.event.inputs.bottoken }}" >> $GITHUB_ENV
        echo "TELEGRAM_USER_ID=${{ github.event.inputs.chatid }}" >> $GITHUB_ENV
        echo "CLOUDFLARE_TUNNEL_TOKEN=${{ github.event.inputs.cloudflaretoken }}" >> $GITHUB_ENV

    - name: Create Docker Network
      run: |
        docker network create neko-network
        echo "‚úÖ Docker network created"

    - name: Start Cloudflare WARP Container
      run: |
        echo "üîê Starting Cloudflare WARP container..."

        docker run -d \
          --name warp \
          --network neko-network \
          --cap-add NET_ADMIN \
          --sysctl net.ipv4.ip_forward=1 \
          caomingjun/warp:latest

        echo "‚úÖ WARP container started"

    - name: Setup WARP NAT (iptables routing)
      run: |
        echo "üîß Setting up NAT routing for WARP..."

        docker run -d \
          --name warp-nat \
          --network container:warp \
          --cap-add NET_ADMIN \
          alpine:3.20 \
          sh -c '
            apk add --no-cache iptables >/dev/null &&
            echo "‚è≥ Waiting for CloudflareWARP interface..." &&
            until ip link show CloudflareWARP >/dev/null 2>&1; do sleep 1; done;
            echo "‚úÖ CloudflareWARP interface detected" &&
            iptables -t nat -A POSTROUTING -o CloudflareWARP -j MASQUERADE &&
            iptables -A FORWARD -i eth0 -o CloudflareWARP -j ACCEPT &&
            iptables -A FORWARD -i CloudflareWARP -o eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT &&
            iptables -P FORWARD ACCEPT &&
            echo "‚úÖ NAT rules applied" &&
            tail -f /dev/null
          '

        echo "‚è≥ Waiting for NAT setup to complete..."
        sleep 15

        # Check if NAT container is running
        if docker ps | grep -q warp-nat; then
          echo "‚úÖ WARP NAT container is running"
          docker logs warp-nat 2>&1 | tail -10
        else
          echo "‚ùå WARP NAT container failed"
          docker logs warp-nat
          exit 1
        fi

    - name: Verify WARP Connection
      run: |
        echo "üåç Verifying WARP routing..."

        # Get host IP first
        HOST_IP=$(curl -s https://api.ipify.org)
        echo "::add-mask::$HOST_IP"
        echo "HOST IP: $HOST_IP"

        # Test routing through WARP (using WARP's network namespace)
        echo "Testing connection through WARP routing..."
        MAX_RETRIES=20
        RETRY_COUNT=0
        WARP_IP=""

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."

          # Run curl in WARP's network namespace to test the routing
          WARP_IP=$(docker run --rm --network container:warp curlimages/curl:latest \
            --connect-timeout 5 --max-time 10 \
            https://api.ipify.org 2>/dev/null || echo "")

          if [ -n "$WARP_IP" ] && [ "$WARP_IP" != "failed" ]; then
            echo "‚úÖ WARP routing is working!"
            break
          fi

          RETRY_COUNT=$((RETRY_COUNT + 1))
          sleep 3
        done

        if [ -z "$WARP_IP" ]; then
          echo "‚ùå Failed to verify WARP routing after $MAX_RETRIES attempts"
          echo "Checking WARP container status:"
          docker ps --filter name=warp
          echo ""
          echo "WARP logs:"
          docker logs warp --tail 30
          echo ""
          echo "WARP NAT logs:"
          docker logs warp-nat --tail 30
          exit 1
        fi

        echo "::add-mask::$WARP_IP"
        echo "VPN_IP=$WARP_IP" >> $GITHUB_ENV
        echo "‚úÖ WARP IP: $WARP_IP"

        if [ "$WARP_IP" != "$HOST_IP" ]; then
          echo "‚úÖ WARP is working! IPs are different."
          echo "   Host IP: $HOST_IP"
          echo "   WARP IP: $WARP_IP"
        else
          echo "‚ö†Ô∏è Warning: WARP IP matches host IP, routing might not be working correctly"
        fi

    - name: Pull and Run m1k1o/neko container
      run: |
        IMAGE_NAME="${{ github.event.inputs.image }}"
        echo "::add-mask::$IMAGE_NAME"

        # Try GitHub Container Registry first (ghcr.io)
        GHCR_IMAGE="ghcr.io/m1k1o/neko/${IMAGE_NAME}"
        DOCKERHUB_IMAGE="m1k1o/neko:${IMAGE_NAME}"

        echo "Attempting to pull from GitHub Container Registry..."
        if docker pull "$GHCR_IMAGE"; then
          echo "‚úÖ Successfully pulled from ghcr.io"
          DOCKER_IMAGE="$GHCR_IMAGE"
        else
          echo "‚ö†Ô∏è Failed to pull from ghcr.io, trying Docker Hub..."
          if docker pull "$DOCKERHUB_IMAGE"; then
            echo "‚úÖ Successfully pulled from Docker Hub"
            DOCKER_IMAGE="$DOCKERHUB_IMAGE"
          else
            echo "‚ùå Failed to pull image from both registries"
            exit 1
          fi
        fi

        echo "Using image: $DOCKER_IMAGE"

        # Run Neko container on the same network as WARP
        docker run -d \
          --name neko-container \
          --network neko-network \
          --cap-add=SYS_ADMIN \
          --shm-size="2gb" \
          -e NEKO_PASSWORD=$NEKO_PASSWORD \
          -e NEKO_PASSWORD_ADMIN=$NEKO_PASSWORD_ADMIN \
          -e NEKO_ICESERVERS='[{"urls":["stun:stun.l.google.com:19302","stun:stun1.l.google.com:19302"]}]' \
          -e NEKO_ICELITE=false \
          -v "${GITHUB_WORKSPACE}/policies/chromium/policies.json:/etc/opt/chrome/policies/managed/policies.json" \
          -p 8080:8080 \
          -p 52000-52100:52000-52100/udp \
          "$DOCKER_IMAGE"

        echo "‚úÖ Neko container started"

    - name: Route Neko Traffic Through WARP
      run: |
        echo "üîÄ Routing Neko traffic through WARP..."

        # Get WARP container IP in the shared network
        WARP_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' warp)
        echo "WARP container IP: $WARP_IP"

        # Setup routing in Neko's network namespace
        docker run -d \
          --name neko-route \
          --network container:neko-container \
          --cap-add NET_ADMIN \
          alpine:3.20 \
          sh -c "
            apk add --no-cache iproute2 >/dev/null &&
            echo '‚è≥ Waiting for network interface...' &&
            until ip link show eth0 >/dev/null 2>&1; do sleep 1; done;
            echo '‚úÖ Network interface ready' &&
            ip route replace default via $WARP_IP dev eth0 &&
            echo '‚úÖ Default route set to WARP' &&
            ip route show &&
            tail -f /dev/null
          "

        echo "‚è≥ Waiting for routing setup..."
        sleep 5

        # Verify route container is running
        if docker ps | grep -q neko-route; then
          echo "‚úÖ Neko routing container is running"
          docker logs neko-route 2>&1 | tail -10
        else
          echo "‚ùå Neko routing container failed"
          docker logs neko-route
          exit 1
        fi

        echo "‚úÖ Neko traffic is now routed through WARP"

    - name: Verify Neko is Behind WARP
      run: |
        echo "üîç Verifying Neko is using WARP routing..."
        sleep 10

        # Check if all containers are running
        echo "Checking container status..."
        CONTAINERS=("neko-container" "neko-route" "warp" "warp-nat")
        for container in "${CONTAINERS[@]}"; do
          if docker ps | grep -q "$container"; then
            echo "‚úÖ $container is running"
          else
            echo "‚ùå $container is not running"
            docker ps -a --filter name="$container"
            docker logs "$container" 2>&1 | tail -20
            exit 1
          fi
        done

        # Test that Neko's traffic goes through WARP
        echo ""
        echo "Testing Neko's external IP (should match WARP IP)..."
        NEKO_IP=$(docker exec neko-container wget -qO- https://api.ipify.org 2>/dev/null || echo "failed")

        if [ "$NEKO_IP" = "failed" ] || [ -z "$NEKO_IP" ]; then
          echo "‚ö†Ô∏è Could not verify Neko's external IP"
          echo "Checking route configuration:"
          docker exec neko-route ip route 2>&1 || true
        else
          echo "‚úÖ Neko external IP: $NEKO_IP"
          echo "‚úÖ WARP IP (from earlier): $VPN_IP"

          if [ "$NEKO_IP" = "$VPN_IP" ]; then
            echo "‚úÖ SUCCESS! Neko is routing through WARP!"
          else
            echo "‚ö†Ô∏è Warning: IPs don't match, routing might not be working"
          fi
        fi

        # Show Neko logs
        echo ""
        echo "Neko container logs:"
        docker logs neko-container --tail 20

    - name: Install Cloudflare Tunnel
      run: |
        wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
        sudo dpkg -i cloudflared-linux-amd64.deb
        cloudflared --version

    - name: Run Cloudflare Tunnel
      run: |
        CF_TOKEN="${{ env.CLOUDFLARE_TUNNEL_TOKEN }}"

        if [ -n "$CF_TOKEN" ]; then
          # Named tunnel with token
          echo "Starting named Cloudflare Tunnel (bypassing VPN)..."
          nohup cloudflared tunnel run --token "$CF_TOKEN" > cf-tunnel.log 2>&1 &
          sleep 10

          # Extract URL from logs (named tunnels show their URL)
          CF_URL=$(grep -oE 'https://[a-zA-Z0-9.-]+\.trycloudflare\.com|https://[a-zA-Z0-9.-]+\.[a-z]+' cf-tunnel.log | head -1)

          if [ -z "$CF_URL" ]; then
            echo "‚ö†Ô∏è Could not extract named tunnel URL, using placeholder"
            CF_URL="https://your-tunnel.cfargotunnel.com"
          fi
        else
          # Quick tunnel (random domain)
          echo "Starting quick Cloudflare Tunnel (bypassing VPN)..."
          nohup cloudflared tunnel --url http://localhost:8080 > cf-tunnel.log 2>&1 &
          sleep 10

          # Extract URL from quick tunnel logs
          CF_URL=$(grep -oE 'https://[a-zA-Z0-9.-]+\.trycloudflare\.com' cf-tunnel.log | head -1)

          if [ -z "$CF_URL" ]; then
            echo "‚ö†Ô∏è Could not extract quick tunnel URL"
            CF_URL="https://unavailable.trycloudflare.com"
          fi
        fi

        echo "::add-mask::$CF_URL"
        echo "CF_URL=$CF_URL" >> $GITHUB_ENV
        echo "‚úÖ Cloudflare tunnel configured successfully (VPN bypass enabled)"

    - name: Get IP Addresses
      run: |
        PRIVATE_IP=$(hostname -I | awk '{print $1}')
        PUBLIC_IP=$(curl -s -4 ifconfig.me)
        echo "::add-mask::$PRIVATE_IP"
        echo "::add-mask::$PUBLIC_IP"
        echo "PRIVATE_IP=$PRIVATE_IP" >> $GITHUB_ENV
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

    - name: Send Credentials to Telegram
      env:
        TELEGRAM_BOT_TOKEN: ${{ env.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_USER_ID: ${{ env.TELEGRAM_USER_ID }}
      run: |
        RUN_ID="${{ github.run_id }}"
        echo "::add-mask::$RUN_ID"

        # Use HTML format with VPN info
        MESSAGE="üöÄ <b>${{ github.event.inputs.image }} is Now Live! (VPN Protected)</b>%0A%0A"
        MESSAGE+="‚òÅÔ∏è <b>Cloudflare Tunnel:</b> <a href=\"${CF_URL}\">Click Here</a>%0A%0A"
        MESSAGE+="üîê <b>VPN Status:</b> ‚úÖ Protected by Cloudflare WARP%0A"
        MESSAGE+="üåç <b>VPN IP:</b> <code>${VPN_IP}</code>%0A"
        MESSAGE+="üåé <b>Host IP:</b> <code>${PUBLIC_IP}</code>%0A%0A"
        MESSAGE+="üîπ <b>Neko Password:</b> <code>${NEKO_PASSWORD}</code>%0A"
        MESSAGE+="üîπ <b>Neko Admin Password:</b> <code>${NEKO_PASSWORD_ADMIN}</code>%0A%0A"
        MESSAGE+="‚ÑπÔ∏è <b>Note:</b> Your connection to Neko is VPN-free, but Neko's internet traffic goes through Cloudflare WARP%0A%0A"
        MESSAGE+="üÜî <b>Run ID:</b> <code>${RUN_ID}</code>"
        INLINE_KEYBOARD='{"inline_keyboard":[[{"text":"Cancel","callback_data":"'"$RUN_ID"'"}]]}'

        echo "Sending credentials to Telegram..."

        RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -d "chat_id=$TELEGRAM_USER_ID" \
          -d "text=$MESSAGE" \
          -d "parse_mode=HTML" \
          -d "reply_markup=$INLINE_KEYBOARD")

        # Check if message was sent successfully
        if echo "$RESPONSE" | grep -q '"ok":true'; then
          echo "‚úÖ Message sent successfully!"
        else
          echo "‚ùå Failed to send message!"
          ERROR_DESC=$(echo "$RESPONSE" | grep -o '"description":"[^"]*"' | cut -d'"' -f4)
          if [ -n "$ERROR_DESC" ]; then
            echo "Error: $ERROR_DESC"
          else
            echo "No error description available"
          fi
          exit 1
        fi

    - name: Keep instance alive (6 hours with periodic health checks)
      run: |
        echo "Instance is running. Performing periodic health checks..."
        END_TIME=$((SECONDS + 21600))  # 6 hours from now

        while [ $SECONDS -lt $END_TIME ]; do
          # Check if all critical containers are still running
          CRITICAL_CONTAINERS=("neko-container" "neko-route" "warp" "warp-nat")
          for container in "${CRITICAL_CONTAINERS[@]}"; do
            if ! docker ps | grep -q "$container"; then
              echo "‚ö†Ô∏è $container stopped unexpectedly!"
              docker logs "$container" 2>&1 | tail -30
              exit 1
            fi
          done

          # Health check
          if curl -sf http://localhost:8080 > /dev/null 2>&1; then
            echo "‚úÖ Health check passed at $(date)"
          else
            echo "‚ö†Ô∏è Health check failed at $(date)"
          fi

          # WARP connection check
          WARP_STATUS=$(docker run --rm --network container:warp curlimages/curl:latest \
            --connect-timeout 5 --max-time 10 \
            https://api.ipify.org 2>/dev/null || echo "failed")
          if [ "$WARP_STATUS" != "failed" ] && [ -n "$WARP_STATUS" ]; then
            echo "‚úÖ WARP still connected: $WARP_STATUS"
          else
            echo "‚ö†Ô∏è WARP connection check failed at $(date)"
          fi

          # Sleep for 5 minutes before next check
          sleep 300
        done

        echo "üïê 6 hour limit reached. Shutting down gracefully..."

    - name: Send Error Notification
      if: failure()
      env:
        TELEGRAM_BOT_TOKEN: ${{ env.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_USER_ID: ${{ env.TELEGRAM_USER_ID }}
      run: |
        RUN_ID="${{ github.run_id }}"
        REPO="${{ github.repository }}"
        echo "::add-mask::$RUN_ID"
        echo "::add-mask::$REPO"

        ERROR_MESSAGE="‚ùå <b>VPN-Protected Deployment Failed</b>%0A%0A"
        ERROR_MESSAGE+="üÜî <b>Run ID:</b> <code>$RUN_ID</code>%0A"
        ERROR_MESSAGE+="üîó <b>Logs:</b> <a href=\"https://github.com/$REPO/actions/runs/$RUN_ID\">View Details</a>"

        echo "Sending error notification..."

        RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -d "chat_id=$TELEGRAM_USER_ID" \
          -d "text=$ERROR_MESSAGE" \
          -d "parse_mode=HTML")

        # Check without printing full response
        if echo "$RESPONSE" | grep -q '"ok":true'; then
          echo "‚úÖ Error notification sent!"
        else
          echo "‚ö†Ô∏è Failed to send error notification (non-critical)"
        fi

    - name: Cleanup Resources
      if: always()
      run: |
        echo "üßπ Cleaning up resources..."

        # Stop and remove Docker containers in correct order
        # First stop containers that use other containers' network namespaces
        echo "Stopping routing containers..."
        docker stop neko-route 2>/dev/null || true
        docker stop warp-nat 2>/dev/null || true

        # Then stop main containers
        echo "Stopping main containers..."
        docker stop neko-container 2>/dev/null || true
        docker stop warp 2>/dev/null || true

        # Remove all containers
        echo "Removing containers..."
        docker rm neko-route neko-container warp-nat warp 2>/dev/null || true

        # Remove network
        docker network rm neko-network 2>/dev/null || true

        # Kill tunnel processes
        pkill -f cloudflared || true

        # Show cleanup summary
        echo "‚úÖ Cleanup completed"
        docker ps -a | grep -E "neko-|warp" || echo "All containers removed"
        pgrep -f "cloudflared" || echo "All tunnel processes stopped"
